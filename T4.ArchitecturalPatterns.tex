\documentclass{beamer}
\mode<presentation>
{
  \usepackage{theme/theme}
  \setbeamercovered{transparent}
}

\usepackage{amsmath,amssymb,amsfonts}
\usepackage{times}
\usepackage{graphicx}
\usepackage{fancyvrb}
\usepackage{array}
\usepackage{colortbl}
\usepackage{tabularx}
\usepackage{fontspec}
\usepackage{minted}

% Uncomment me when you need to insert code
\usepackage{color}
\usepackage{listings}
% End Code

% End Header

% Titlepage
\newcommand{\maintitle}{T4. Architectural Patterns}
\title{\maintitle}
\author{Enterprise Software Architectures}
\institute
{
  Bachelor's Degree in Computer Engineering
}
\date{Academic year 2025/26}
% End Titlepage

\AtBeginSection[]{
  \begin{frame}
    \centering
    \begin{beamercolorbox}[sep=8pt,center]{title}
      \usebeamerfont{title}\insertsectionhead
    \end{beamercolorbox}
  \end{frame}
}

% Slides
\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}
  \frametitle{\maintitle}
  \tableofcontents[subsectionstyle=show]
\end{frame}

\section{Block A - Introduction to Architectural Patterns}

\begin{frame}
  \frametitle{Architecture vs. Design (real world)}
  
  Discuss similarities / differences between \textit{Architecture} and \textit{Design}:
  \begin{columns}
    \column{.5\linewidth}
      \begin{figure}
        \includegraphics[width=1\textwidth]{images/T4/real-world-architecture.png}
        \caption{Architectural drawing of a house. Source: \href{https://commons.wikimedia.org/wiki/File:Architectural_Drawing.gif}{Wikimedia Commons}}
      \end{figure}
    \column{.5\linewidth}
      \begin{figure}
        \includegraphics[width=1\textwidth]{images/T4/real-world-design.png}
        \caption{Interior design drawing. Source: \href{https://commons.wikimedia.org/wiki/File:Architectural_Drawing.gif}{Tihon Grenaderov at SuperColoring (license: CC BY-NC 4.0)}}
      \end{figure}
  \end{columns}
\end{frame}

\begin{frame}
  \frametitle{Architecture vs. Design (real world)}
  
  Both are very similar, but at \textit{different scales}. This gives them different properties:
  \newline

  Architecture...
  \begin{itemize}
    \item is about the \textbf{overall structure} of the building.
    \item has a large impact on its \textbf{integrity and reliability}.
    \item An architectural mistake is much \textbf{harder to fix} after the fact.
  \end{itemize}

  Design...
  \begin{itemize}
    \item focuses on \textbf{smaller details}.
    \item occurs \textbf{in parallel or slightly after} architecture.
    \item is \textbf{constrained by} the architectural boundaries (rooms), and must \textbf{fit and complement} them.
  \end{itemize}

\end{frame}

\begin{frame}
  \frametitle{Software Architecture and Design}

  The same concepts transfer to the context of Software Engineering.
  \newline

  Architecture...
  \begin{itemize}
    \item is about the \textbf{high-level structure} of the software system.
    \item defines \textbf{major components}, their responsibilities, and how they interact.
    \item has a large impact on its \textbf{reliability, security, scalability and performance}.
    \item An architectural mistake is much \textbf{harder to fix} after the fact.\footnote{Real-world case study: \href{https://web.archive.org/web/20240325042615/https://www.primevideotech.com/video-streaming/scaling-up-the-prime-video-audio-video-monitoring-service-and-reducing-costs-by-90}{Why Amazon Prime Video had to switch back from microservices to a monolith.}}
  \end{itemize}

 
\end{frame}

\begin{frame}
  \frametitle{Software Architecture and Design}

  Design...
  \begin{itemize}
    \item focuses on \textbf{smaller, lower-level components}.
    \item occurs \textbf{in parallel or slightly after} architecture. Both are part of the \textit{Design stage}.
    \item is \textbf{constrained by} the architectural boundaries (high-level decisions), and must \textbf{fit and complement} them.
  \end{itemize}
  {\color{white} . }
  
  In other words, design \textit{fills in the details} within the architectural framework.
\end{frame}

\begin{frame}
  \frametitle{Architectural Patterns}

  \begin{itemize}
    \item \textbf{Design Pattern}: Reusable solution to a common \textit{design problem}.
    \item \textbf{Architectural Pattern}: Reusable solution to a common \textit{architectural problem}.
  \end{itemize}
  {\color{white} . }

  Therefore, architectural patterns are well-known ways to organize our system at a high level.
\end{frame}

\section{Block B - Important architectural patterns}

\subsection{Layered architecture}
\begin{frame}
  \frametitle{Layered architecture}
  Also known as \textit{tiered}, \textit{N-layer} or \textit{N-tier} architecture.
  \newline

  \textbf{The Problem:} How can we decompose a complex problem in a way that promotes \textit{separation of concerns}?
  \newline

  \textbf{The Solution:} Organize the system into \textit{layers}:
  \begin{itemize}
    \item Layers can be separated logically (different modules) or physically (different machines).
    \item Each layer is only allowed to \textbf{depend on those below it} (use their services). It is unaware of layers above it.
    \item Conceptually, the \textit{User} is at the topmost layer.
  \end{itemize}

\end{frame}

\begin{frame}
  \frametitle{Layered architecture: Variants}
  
  \textbf{Strict layered architecture}: Each layer can only communicate with the \textit{layer directly below it}.
  \newline

  \textbf{Relaxed layered architecture}: Layers can communicate directly with \textit{any layer below them}.

  \begin{itemize}
    \item Advantages:
    \begin{itemize}
      \item More flexibility.
      \item Potentially higher performance (skip the overhead of intermediate layers).
    \end{itemize}
    \item Disadvantages:
    \begin{itemize}
      \item Much higher coupling ($O(n^2)$ potential dependencies instead of $O(n)$).
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}
  \frametitle{Layered architecture example: The OSI model}
  
  \begin{figure}
    \includegraphics[width=1\textwidth]{images/T4/osi-model.pdf}
    \caption{7-layer OSI model}
  \end{figure}

  Is it \textit{strict} or \textit{relaxed}? Is the separation physical or logical?
\end{frame}


\begin{frame}
  \frametitle{Layered architecture: Disadvantages}
  
  \begin{itemize}
    \item Deciding \textbf{which layers} to create and which \textbf{responsibilities} to assign to each layer can be hard.
    \item Can have \textbf{lower performance}, since requests must traverse multiple layers.
    \begin{itemize}
      \item If the separation between layers is just logical, the added overhead is usually negligible.
    \end{itemize}
    \item Can cause \textbf{model duplication} (potential DRY violation).
    \begin{itemize}
      \item New/modified fields might require similar changes to the data structures in multiple layers.
      \item This is often mitigated in modern languages or frameworks.
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{3-layer architecture}
\begin{frame}
  \frametitle{3-layer architecture}

  Specific case of layered architecture with 3 layers:
  \begin{itemize}
    \item \textbf{Presentation layer}: Interaction with the user or client application (UI or API).
    \item \textbf{Application/Domain layer}: Application-specific domain and business logic. Data processing and algorithms.
    \item \textbf{Persistence/Data layer}: Data sources for storing and reading information.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{3-layer architecture example: Client-Server-DB architecture}

  \begin{figure}
    \includegraphics[width=1\textwidth]{images/T4/3-layer.pdf}
  \end{figure}
  Is it \textit{strict} or \textit{relaxed}? Is the separation physical or logical?
\end{frame}

\subsection{Hexagonal architecture}
\begin{frame}
  \frametitle{Improving the layered architecture}

  The traditional layered architecture violates the \textbf{Dependency Inversion Principle}, because high-level layers depend on low-level layers (details).
  
  This causes 2 problems:
  \begin{itemize}
    \item Coupling Presentation $\rightarrow$ Application: UI code can get contaminated with domain logic.
    \item Coupling Application $\rightarrow$ Persistence: Domain is hard to fully test in isolation, because it depends on the database.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Applying the Dependency Inversion Principle}

  \begin{figure}
    \includegraphics[width=1\textwidth]{images/T4/hexagonal-1.pdf}
  \end{figure}
\end{frame}

\begin{frame}
  \frametitle{Taking one step further: Hexagonal architecture}

  For more complex applications, we can extend this idea to add more interfaces:
  \begin{figure}
    \includegraphics[width=1\textwidth]{images/T4/hexagonal-2.pdf}
  \end{figure}

\end{frame}

\begin{frame}
  \frametitle{Hexagonal architecture}

  This is known as \textbf{Hexagonal architecture}\footnote{Note that the "Hexagonal" name and shape are just metaphorical, the architecture can have an arbitrary number of ports.} or \textbf{Ports and Adapters architecture}.

  Let's redraw the previous diagram the way it's usually represented:
  \begin{figure}
    \includegraphics[width=1\textwidth]{images/T4/hexagonal-3.pdf}
  \end{figure}

\end{frame}

\section{Block C - Domain Layer Patterns}
\subsection{Transaction Script}
\begin{frame}
  \frametitle{Transaction Script}

  \textbf{The Problem:} How can we organize the \textit{domain logic} (business rules and processes) of our application, the simplest way possible?
  \newline

  \textbf{The Solution:} For each API endpoint, write one procedure (function) that handles the entire transaction.\footnote{\url{https://martinfowler.com/eaaCatalog/transactionScript.html}} 
  \newline
  
  If procedures get too big, or the same code gets repeated (DRY violation), extract smaller \textit{helper functions}.
\end{frame}

\begin{frame}
  \frametitle{Transaction Script}
  \begin{figure}
    \includegraphics[height=0.85\textheight]{images/T4/transaction-script.pdf}
  \end{figure}
\end{frame}

\begin{frame}
  \frametitle{Transaction Script: Advantages}

  \begin{itemize}
    \item Transaction boundaries are obvious.
    \item It's a good fit for applications with \textbf{simple data} and \textbf{linear workflows} (KISS principle).
    \item It's the most natural option in purely \textbf{procedural languages} like C.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Transaction Script: Disadvantages}

  \begin{itemize}
    \item It \textbf{doesn't scale well} for complex domains.
    \begin{itemize}
      \item Difficult to maintain and understand for complex, highly interconnected data structures.
    \end{itemize}
    \item \textbf{Weak reusability} and composition.
    \begin{itemize}
      \item Logic is organized around use-cases instead of domain concepts, which can create hidden duplication.
    \end{itemize}
    \item \textbf{Low cohesion}.
    \begin{itemize}
      \item Related logic is scattered across multiple procedures instead of being grouped together.
    \end{itemize}
    \item \textbf{Hard to extend}.
    \begin{itemize}
      \item New fields may require modifying all existing procedures.
      \item New endpoints require writing a full new procedure, instead of hooking into reusable components.
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Domain Model}
\begin{frame}
  \frametitle{Domain Model}

  \textbf{The Problem:} How can we organize the \textit{domain logic} (business rules and processes) of our application, in a way that promotes \textit{reusability} and \textit{extensibility}?
  \newline

  \textbf{The Solution:}
  \begin{enumerate}
    \item Create a \textbf{rich object model} that closely represents the \textbf{actual domain concepts} and their relationships.\footnote{\url{https://martinfowler.com/eaaCatalog/domainModel.html}}
    \begin{itemize}
      \item In other words, your domain layer should look as similar as possible to your UML class diagram.
    \end{itemize}
    \item Implement the domain logic as \textbf{methods} on these objects, instead of separate procedures.
  \end{enumerate}
\end{frame}

\begin{frame}
  \frametitle{Domain Model}

  \begin{figure}
    \includegraphics[width=1\textwidth]{images/T4/domain-model.pdf}
  \end{figure}

\end{frame}

\begin{frame}
  \frametitle{Domain Model: Advantages}

  \begin{itemize}
    \item \textbf{Scales well} for complex domains.
    \begin{itemize}
      \item A domain with many interconnected concepts can be easily represented as a graph of objects with relationships.
    \end{itemize}
    \item Very high \textbf{cohesion} and \textbf{reusability}.
    \begin{itemize}
      \item Data and its corresponding behavior are encapsulated in the same class.
      \item The behavior can be easily reused by all use-cases/endpoints that interact with that domain concept.
    \end{itemize}
    \item Good \textbf{extensibility} and long-term \textbf{maintainability}.
    \begin{itemize}
      \item New fields or logic only require modifying the relevant classes, without affecting unrelated parts of the code.
      \item Promotes the use of \textbf{polymorphism} and behavior delegation through composition (\href{https://en.wikipedia.org/wiki/GRASP_(object-oriented_design)}{\textit{Expert} pattern}).
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Domain Model: Disadvantages}

  \begin{itemize}
    \item It requires strong \textbf{Object-Oriented Programming} (OOP) support.
    \begin{itemize}
      \item This is the reason why Java and C\# currently dominate the enterprise software market.
    \end{itemize}
    \item Mapping between the domain model (graph-like structure) and the database (relational tables) can be complex.
    \begin{itemize}
      \item This is known as \href{https://en.wikipedia.org/wiki/Object\%E2\%80\%93relational_impedance_mismatch}{\textbf{object-relational impedance mismatch}}.
      \item Mitigated by using \href{https://en.wikipedia.org/wiki/Object\%E2\%80\%93relational_mapping}{\textbf{Object-Relational Mapping (ORM)}} libraries, but this adds significant complexity and performance overhead.
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Table Module}
\begin{frame}
  \frametitle{Table Module}

   \textbf{The Problem:} How can we get some of the \textbf{reusability benefits} of the Domain Model pattern, \textbf{without using OOP}?
  \newline

  \textbf{The Solution:}
  \begin{enumerate}
    \item Create a "table module" class for each \textbf{database table}/view, instead of for each domain concept.\footnote{\url{https://martinfowler.com/eaaCatalog/tableModule.html}}
    \begin{itemize}
      \item Table modules are \textit{singletons} (one instance manages all rows in the table), as opposed to Domain Model objects.
    \end{itemize}
    \item Implement the domain logic as \textbf{class methods} that operate on the data in the table.
  \end{enumerate} 
\end{frame}

\begin{frame}
  \frametitle{Table Module}

  \begin{figure}
    \includegraphics[height=0.85\textheight]{images/T4/table-module.pdf}
  \end{figure}

\end{frame}

\begin{frame}
  \frametitle{Table Module: Advantages}

  \begin{itemize}
    \item \textbf{More structured than Transaction Script}.
    \begin{itemize}
      \item The DB tables roughly correspond to domain concepts, and the logic related to each concept is grouped together.
      \item Scales moderately well for complex domains, as long as the domain logic is mostly CRUD operations on the database.
    \end{itemize}
    \item Unlike Domain Model, it \textbf{doesn't require OOP} support.
    \begin{itemize}
      \item Table modules can be implemented as a simple module with static functions.
    \end{itemize}
    \item \textbf{Direct mapping} to relational database tables, without the need for complex ORM libraries.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Table Module: Disadvantages}

  \begin{itemize}
    \item Tight \textbf{coupling} between the \textit{domain logic} and the \textit{data access}.
    \begin{itemize}
      \item This makes it hard to test the domain logic in isolation.
      \item Changes to the database schema can require significant changes to the domain logic.
    \end{itemize}
    \item It lacks inheritance and other OOP features that promote \textbf{code reuse} and \textbf{extensibility}.
    \begin{itemize}
      \item For complex domains, this can lead to the same cohesion and maintainability issues as Transaction Script.
    \end{itemize}
  \end{itemize}

\end{frame}

\end{document}
